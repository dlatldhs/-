# IT 취업을 위한 대비 질문 모음집

> ### **Operating System**
> ##### <details markdown="1"><summary>프로세스와 쓰레드의 차이점</summary> - 프로세스 : 간단히 말하면 실행중인 프로그램<br> - 쓰레드 : 경량화 된 프로세스<br>운영체제는 자원을 효율적으로 사용하려고 함. --> 쓰레드를 사용하면 프로세스에 비해서<br>생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적음.<br>그리고 쓰레드를 사용하면 병렬성을 높일 수 있음.<br></details>
> ##### <details markdown="1"><summary>리눅스를 사용하는 이유</summary> - 높은 보안성 : 리눅스가 오픈소스이기 때문에 어떤 보안 취약성을 가지고 있는지 알 수 있고 , 보안 취약성을 여러 사람들이 파악하여 빠른 특성으로 높은 보안성을 가질 수 있음<br> - 안정된 구조 : 매우 안정적이며 충돌이 잘 발생안함 , 리눅스 서버의 가동 시간은 매우 높고 없데이트 또는 패치 후 리눅스를 재부팅할 필요가 없음<br> - 유지보수의 용이함 : 업데이트는 시스템을 재부팅하지 않고도 가능함 -> 유지보수에 좋음<br> - 어떤 하드웨어에서도 동작함 : 하드웨어나 모듈같은거 깔 때 에러가 윈도우보다 덜 남 , 하드웨어 이식성이 좋음<br> - 무료/오픈소스 : 무료이고 오픈소스이다.</details>
> ##### <details markdown="1"><summary>교착상태(데드 락 Deadlock)의 4가지 발생조건</summary>1. 자원점유와 대기<br>- 프로세스가 자원을 최소 하나는 보유해야함 / 다른 프로세스에 할당된 자원을 점유하기 위해선 대기하는 프로세스가 있어야함(대기해야한다는거)<br>2. 비선점<br>- 이미 할당된 자원을 뺏을 수 없음(자원 약탈 불가능)<br>3. 순환적 자원 요구<br>- 말 그대로임 대기 프로세스 집합이 순환 형태로 자원을 기다려야 한다는거임<br>4. 상호배제<br>  - 한번의 하나의 프로세스만 해당 자원을 사용하게 해주는거<br>해결법<br>- 예방(발생 조건 4가지 중 하나라도 차단하는거)<br>- 회피<br>- 탐지/회복</details>
> ##### <details markdown="1"><summary>운영체제의 이중모드를 설명하시오.</summary>이중모드(=dual mode) : CPU의 사용 모드 즉 사용 방법을 2개로 구분한 것(사용자모드 , 커널모드 ).<br>사용자 모드 : 운영체제 서비스를 제공받을 수 없는 모드 , 기본적인 프로그램은 사용자 모드로 실행이 된다. 하지만 하드웨어 자원을 사용해야할 때에는 커널모드로 바뀌게 된다. 즉 사용자 모드는 하드웨어 자원이 사용불가한 모드를 뜻한다.<br>커널 모드 : 사용자 모드와 반대로 운영체제 서비스를 받을 수 있는 모드이다. 하드웨어 자원 이나 중요한 자원으로 접근해야할 때 사용이 된다.<br>플래그 레지스터 속 슈퍼바이저 플래그를 보면 지금 어떤 모드인지 볼 수 있다. `1`일 경우 커널 모드이고 , `0`일 경우 사용자 모드로 실행 중 임을 의미한다.</details>
> ##### <details markdown="1"><summary>시스템 콜</summary>사용자 모드로 실행되는 프로그램이 하드웨어 자원에 접근을 해야하거나 운영체제 서비스를 제공 받으려고 한다면 사용자 모드에서 커널 모드로 모드 변경이 이루어 져야 한다. 이때 모드 변경을 하기 위한 방법은 시스템 호출( System call ) 이라는 것이 있다. `시스템 콜`은 일종의 인터럽트 형태이다. 소프트웨어 적인 인터럽트이다. 그래서 인터럽트 처리 순서와 유사하다.<br>1. 시스템 호출 발생시켜 커널 모드로 전환<br>2. 운영체제 내의 '하드 디스크에 데이터를 저장하는 코드'를 싱행함으로써 하드 디스크에 접근 가능.(운영체제 코드 실행)<br>3. 사용자 모드로 복귀 하여 실행 이어감.<br>![image](https://user-images.githubusercontent.com/80656700/217559327-9081138d-d22e-4f87-9c95-6d62daba1f0e.png)
</details>

---------------------------------------------------------
> ### **Network**
> ##### <details markdown="1"><summary>TCP 와 UDP 차이점</summary>TCP<br>1. 신뢰성과 순차적인 전달이 필요한 경우 사용<br>2. 송진자와 수진사 모두가 `소켓`이라고 부르는 것을 생성함<br>3. 멀티캐스팅이나 브로드 캐스팅을 지원안함<br>4. 사전설정 필요 O<br>UDP<br>1. 비연결형 프로토콜<br>2. 손상된 세그먼트의 수신에 대한 재전송X<br>3. 사전설정 필요 X <br></details>
---------------------------------------------------------
> ### **메모리**
> ##### <details markdown="1"><summary> 1.1 + 0.1 == 1.2 가 틀린 이유</summary>1. 컴퓨터가 정수를 저장할 때에는 메모리에다가 2진법으로다가 저장을 함. `IEEE` 미국 전자 전기 협회 ? 같은데인데 여기서 정한 표준을 사용하여 기본적으로 32칸 정도를 확보함. 그리고 저장을 때림<br>2. 실수 저장<br>실수는 일단 `정수부`랑 `소수부`가 있는데 영어로는 `mantissa`라고 하는거 같음. 32bit 즉 4byte정도에서 1bit는 `MSB` 8bit 는 `정수부` 그리고 나머지 23bit는 `mantissa`를 저장함![image](https://user-images.githubusercontent.com/80656700/184537622-b8252470-f6c2-4579-bbca-202c14e71abe.png)<br>3. 근데 0.1 같은건 2진법으로 저장을 하기가 힘듬 , 0.1 같은건 이진법으로 정확하게 표현이 안되서 23 bit 까지 짤림 그래서 정확하게 계산이 되지 않아서 <br>`1.1 + 0.1 == 1.2` 이 수식이 틀린거임<br>해결방법<br>1. n*100 하기( 실수를 그냥 정수로 만들어버려서 저장을 해버리는거임 )<br>2. 반올림 문법 사용하기<br>3.double 자료형 사용하기( double은 더 많은 공간을 확보하기 때문에 조금 더 정확함 float보다 )<br><a href="https://fabl1106.github.io/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/2019/03/10/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99-04.-%EC%8B%A4%EC%88%98%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%98%EB%8A%94-%EB%B2%95.html">자료출처</a></details>
> ##### <details markdown="1"><summary>힙 영역과 스택영역의 차이점</summary>1. 프로그램이 실행되기 위해 메모리에 로드가 되야한다. 운영체제는 따라서 메모리에 할당을 해줌<br>![image](https://user-images.githubusercontent.com/80656700/186429879-6d199e32-9895-48dd-8007-a6663bcc32f4.png) 메모리 공간은 다음과 같음.<br>1. 코드 : 코드가 저장됨. 여기서 cpu가 하나 하나 씩 가져가서 실행을 함<br>2. 데이터 영역 : 전역 & 정적 변수가 저장됨 , 프로그램이 실행되면 바로 할당됨 <br>3. 스택 영역 : 함수의 호출과 관계가 있는 지역변수하고 매개변수가 저장되는 영역( 함수 시작시 할당 종료시 종료)<br>4. 힙 영역 : 사용자가 직접 관리할 수 있는 메모리 영역, 사용자에 의해서 메모리 공간이 동적으로 할당됨 </details>
> ##### <details markdown="1"><summary>32bit와 64bit의 차이점 With CPU</summary>word: 한번에 cpu가 처리할 수 있는 데이터 크기 , word의 크기에 따라서 cpu 성능도 달라진다. 또한 보통의 컴퓨터라면 word의 크기는 데이터 버스의 크기와 같다.<br>32bit 와 64bit의 차이점(CPU)<br>1. 32bit CPU는 데이터를 32bit 만큼 쪼개서 보내거나 수행을 함<br>2. 64bit CPU는 데이터를 64bit 만큼 쪼개서 함<br>so 한번에 실행을 하는 데이터의 크기가 64bit가 더 많다. 이 말의 의미는 데이터를 주고 받는 입출력의 횟수가 줄어들고 , 연산이 빨라진다는거임<br>결론 : 매우 많은 차이가 있다.</details>
> ##### <details markdown="1"><summary>인증과 인가의 차이</summary>인증(Authentication)<br> - 신원을 검증하는 행위 , 인증프로세스(비밀번호, 일회용 핀 등) 구성하여 1가지 이상이 성공되야 시스템에 접근 가능<br>인가(Authorization)<br> - 사용자에게 특정 리소스 & 기능에 접근할 수 있는 권한을 부여하는 프로세스<br> 인증은 사용자가 부분적으로 직접 변경할 수 있지만 , 인가는 접근 완전 불가능</details>
--------------------------------------------------------
> ### **백엔드**
> ##### <details markdown="1"><summary>세션 방식과 JWT 방식</summary>`세션 인증방식과 토큰 인증 방식의 차이점`<br>세션 : 인증 정보가 서버에 저장되어 있는 상태 , Client는 쿠키 헤더에 세션 ID 를 같이 보낸다. 서버에서는 세션 ID를 받아서 이걸 활용하여 인증을 확인한다.<br>JWT(JSON WEB TOKEN) : 인증 정보를 모두 Client가 들고 있다. 그래서 서버에서는 세션 방식과 같이 받아서 확인을 하는 절차를 밟지 않아도 되기 때문에 부담이 덜 간다.(사용자가 많은 경우에 부담이 덜감) , 그리고 쿠키에 모든 정보(?)를 담아서 보냄 , 서버에서는 만료 시각이 지나지 않았는지만 확인하고 통과 시킴<br> 이러한 방식으로 인해서 JWT 는 많은 보안 이슈를 불러 일으킬 수 있음 , 근데 잘 만 하면 괜찮음</details>
> ##### <details markdown="1"><summary>매개변수와 인자의 차이점</summary>매개변수 : 함수를 정의할 때 사용되는 변수<br> 인자 : 실제로 함수가 호출될 때 넘기는 변수값<br> => 인자는 함수를 호출할 때 넣는 거를 의미함 , 매개변수는 함수입장에서 해석을 하는거임 ![image](https://user-images.githubusercontent.com/80656700/213203059-a36d050b-6b5b-4858-a7e2-dcf89f5d7203.png)
</details>

--------------------------------------------------------

> ### **임베**
> ##### <details markdown="1"><summary>chip 차이점</summary>1. SoC( System on Chip ) : chip 안에 IC 제어 , 연산장치 , 저장장치 , 입출력 장치 등이 싹 다 들어가 있는 chip. 보통 MCU 와 MPU에 많이 있음<br>2.CPU( Central Processing Unit ) : 산술 논리 연산 유닛인 ALU 와 명령어를 읽어오라고 해석하여 제ㅐ어하는 CU를 묶은 형태. 입출력은 CPU에서 제어를 하지만 CPU 자체는 I/O, memory 를 가지고 있지는 않다.(이게 중요한듯) 즉 CPU 는 자기 혼자서는 아무것도 못함<br>3. MPU (micro processing Unit) : CPU의 축소판이다. CPU와 마찬가지로 I/O , memory를 가지고 있지 않다. CL + ALU 형태이며 임베디드 쪽으로 주로 사용됨.<br> MCU(Micro Controller Unit) : 대표적인 SoC 형태로 Chip 안에 CU , ALU , I/O , Memory 를 모두 가지고 있다. 추가적인 로직 회로 없이 모든 것을 chip 하나로 해결할 수 있기에 PCB 보드의 부피를 줄일 수 있따. MICOM 이라고도 부른다. MICOM = MCU<br>GPU(Graphics Processing Unit ) : CPu은 정수 연산을 잘하지만 소수점 연산은 취약하다. 그래서 GPU가 소수점 연산을 함. 소수점 파트는 얘가 빠름<br>DSP ( Digital Signal Processor) : 주된 용도는 신호처리. 아날로그 신호를 디지털로 고속 변환하여 계산 , 사용해서 DSP 라고 함. CPU , MPU , MCU 들은 명령어의 해석 및 처리도 하고 계산도 하고 멀티 플레이가 됨 근데 DSP 와 GPU 는 오직 계산만하기 위해서 만들어짐. 약간 계산만 함.(=주목적)<br>FPGA(Field Programmable Gate Array): Chip 상에 논리회로를 구성해서 자신이 원하는 기능을 회로로만드는 거임 . 물리적으로 회로도를 만들지 않고 chip 상에서 구현할 수 있음. C 프로그램 하듯 H/W를 프로그래밍 할 수 있음. H/W 에서 구현된 알고리즘은 실행 속도가 빠르므로 암호 알고리즘 , 영상처리 등에 쓰임.<br>ASIC( Application Specific Integrated Circuit ) : 특정한 기능 , Application에 딱 맞춰 생산하는 반도체.<br>Firmware : 특정 하드웨어 장치에 특정 목적을 위하여 만들어진 소프트웨어를 말함. ROM이나 EEPROM 에 저장되며 ROM에 직접 Writing을 한다.<br>BSP( Board Support Package ) : 임베디드 시스템의 설계 또는 Board를 사용하기 제공하는 프로그램 모음집,모음툴 같은거. BSP는 Chip 회사에서 제공하는 SoC Chip 내장되어 있는 보드를 구동시키는 프로그램. 모든 장치를 위한 드라이버 같음. 기본적으로 부트로더(Bootloader),OAL(OEM Adaption Layer: 추상화 계층 하드웨어 초기화 및 관리) , Device Driver(특정 하드웨어 or 장치 제어 위한 커널의 일부분 , 드라이버가 프로그램 되어 커널에 통합됨=> 프로그램형 드라이버)이 3개가 있다.</details>
> #####  <details markdown="1"><summary>CLI를 사용하는 이유</summary>CLI = Command Line Interface 의 약자 , 명령어 기반 인터페이스를 뜻함.<br>사용하는 이유 1. 메모리를 덜 사용함<br>2. 다중 명령어 등을 활용하여 더 빠르게 효율적으로 결과를 볼 수 있음.<br>3. 네트워크 환경에서도 사용 가능함.<br> 다중명령어 => `|`(파이프), `;`(세미콜론),`&&`(엔퍼센트)를 활용해서 함. 명령어를 동시에 수행하는거임.</details>

> ### **Basic CS**
> #####  <details markdown="1"><summary>클라우드 컴퓨팅 이란?</summary>컴퓨터 자원을 빌려쓰는 개념. 여기서 컴퓨터 자원은 cpu, 메모리 등이 있다. 쓴만큼 돈을 지불하는 일종의 종량제. </details>
> #####  <details markdown="1"><summary>컴퓨터의 성능을 향상시키는 방법에는 무엇이 있나요?</summary>스케일 업, 스케일 아웃. 말 그래도 성능이 좋은 RAM을 쓴다던지 좋은 cpu를 쓰는 것. 다른 하나는 연산을 처리할 수 있는 프로세스를 여러개 두어 분산처리 하도록 하는 것.</details>
