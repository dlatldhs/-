# IT 취업을 위한 대비 질문 모음집

### 분야
#### OS(운영체제)
##### <details markdown="1"><summary>프로세스와 쓰레드의 차이점</summary> - 프로세스 : 간단히 말하면 실행중인 프로그램<br> - 쓰레드 : 경량화 된 프로세스<br>운영체제는 자원을 효율적으로 사용하려고 함. --> 쓰레드를 사용하면 프로세스에 비해서<br>생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적음.<br>그리고 쓰레드를 사용하면 병렬성을 높일 수 있음.<br></details>
##### <details markdown="1"><summary>리눅스를 사용하는 이유</summary> - 높은 보안성 : 리눅스가 오픈소스이기 때문에 어떤 보안 취약성을 가지고 있는지 알 수 있고 , 보안 취약성을 여러 사람들이 파악하여 빠른 특성으로 높은 보안성을 가질 수 있음<br> - 안정된 구조 : 매우 안정적이며 충돌이 잘 발생안함 , 리눅스 서버의 가동 시간은 매우 높고 없데이트 또는 패치 후 리눅스를 재부팅할 필요가 없음<br> - 유지보수의 용이함 : 업데이트는 시스템을 재부팅하지 않고도 가능함 -> 유지보수에 좋음<br> - 어떤 하드웨어에서도 동작함 : 하드웨어나 모듈같은거 깔 때 에러가 윈도우보다 덜 남 , 하드웨어 이식성이 좋음<br> - 무료/오픈소스 : 무료이고 오픈소스이다.</details>
##### <details markdown="1"><summary>교착상태(데드 락 Deadlock)의 4가지 발생조건</summary>1. 자원점유와 대기<br>- 프로세스가 자원을 최소 하나는 보유해야함 / 다른 프로세스에 할당된 자원을 점유하기 위해선 대기하는 프로세스가 있어야함(대기해야한다는거)<br>2. 비선점<br>- 이미 할당된 자원을 뺏을 수 없음(자원 약탈 불가능)<br>3. 순환적 자원 요구<br>- 말 그대로임 대기 프로세스 집합이 순환 형태로 자원을 기다려야 한다는거임<br>4. 상호배제<br>  - 한번의 하나의 프로세스만 해당 자원을 사용하게 해주는거<br>해결법<br>- 예방(발생 조건 4가지 중 하나라도 차단하는거)<br>- 회피<br>- 탐지/회복</details>
#### Network(네트워크)
##### <details markdown="1"><summary>TCP 와 UDP 차이점</summary>TCP<br>1. 신뢰성과 순차적인 전달이 필요한 경우 사용<br>2. 송진자와 수진사 모두가 `소켓`이라고 부르는 것을 생성함<br>3. 멀티캐스팅이나 브로드 캐스팅을 지원안함<br>4. 사전설정 필요 O<br>UDP<br>1. 비연결형 프로토콜<br>2. 손상된 세그먼트의 수신에 대한 재전송X<br>3. 사전설정 필요 X <br></details>
#### 메모리(memory)
##### <details markdown="1"><summary> 1.1 + 0.1 == 1.2 가 틀린 이유</summary>1. 컴퓨터가 정수를 저장할 때에는 메모리에다가 2진법으로다가 저장을 함. `IEEE` 미국 전자 전기 협회 ? 같은데인데 여기서 정한 표준을 사용하여 기본적으로 32칸 정도를 확보함. 그리고 저장을 때림<br>2. 실수 저장<br>실수는 일단 `정수부`랑 `소수부`가 있는데 영어로는 `mantissa`라고 하는거 같음. 32bit 즉 4byte정도에서 1bit는 `MSB` 8bit 는 `정수부` 그리고 나머지 23bit는 `mantissa`를 저장함![image](https://user-images.githubusercontent.com/80656700/184537622-b8252470-f6c2-4579-bbca-202c14e71abe.png)<br>3. 근데 0.1 같은건 2진법으로 저장을 하기가 힘듬 , 0.1 같은건 이진법으로 정확하게 표현이 안되서 23 bit 까지 짤림 그래서 정확하게 계산이 되지 않아서 <br>`1.1 + 0.1 == 1.2` 이 수식이 틀린거임<br>해결방법<br>1. n*100 하기( 실수를 그냥 정수로 만들어버려서 저장을 해버리는거임 )<br>2. 반올림 문법 사용하기<br>3.double 자료형 사용하기( double은 더 많은 공간을 확보하기 때문에 조금 더 정확함 float보다 )<br><a href="https://fabl1106.github.io/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/2019/03/10/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99-04.-%EC%8B%A4%EC%88%98%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%98%EB%8A%94-%EB%B2%95.html">자료출처</a></details>
##### <details markdown="1"><summary>힙 영역과 스택영역의 차이점</summary>1. 프로그램이 실행되기 위해 메모리에 로드가 되야한다. 운영체제는 따라서 메모리에 할당을 해줌<br>![image](https://user-images.githubusercontent.com/80656700/186429879-6d199e32-9895-48dd-8007-a6663bcc32f4.png) 메모리 공간은 다음과 같음.<br>1. 코드 : 코드가 저장됨. 여기서 cpu가 하나 하나 씩 가져가서 실행을 함<br>2. 데이터 영역 : 전역 & 정적 변수가 저장됨 , 프로그램이 실행되면 바로 할당됨 <br>3. 스택 영역 : 함수의 호출과 관계가 있는 지역변수하고 매개변수가 저장되는 영역( 함수 시작시 할당 종료시 종료)<br>4. 힙 영역 : 사용자가 직접 관리할 수 있는 메모리 영역, 사용자에 의해서 메모리 공간이 동적으로 할당됨 </details>
##### <details markdown="1"><summary>32bit와 64bit의 차이점 With CPU</summary>word: 한번에 cpu가 처리할 수 있는 데이터 크기 , word의 크기에 따라서 cpu 성능도 달라진다. 또한 보통의 컴퓨터라면 word의 크기는 데이터 버스의 크기와 같다.<br>32bit 와 64bit의 차이점(CPU)<br>1. 32bit CPU는 데이터를 32bit 만큼 쪼개서 보내거나 수행을 함<br>2. 64bit CPU는 데이터를 64bit 만큼 쪼개서 함<br>so 한번에 실행을 하는 데이터의 크기가 64bit가 더 많다. 이 말의 의미는 데이터를 주고 받는 입출력의 횟수가 줄어들고 , 연산이 빨라진다는거임<br>결론 : 매우 많은 차이가 있다.</details>
##### <details markdown="1"><summary>인증과 인가의 차이</summary>인증(Authentication)<br> - 신원을 검증하는 행위 , 인증프로세스(비밀번호, 일회용 핀 등) 구성하여 1가지 이상이 성공되야 시스템에 접근 가능<br>인가(Authorization)<br> - 사용자에게 특정 리소스 & 기능에 접근할 수 있는 권한을 부여하는 프로세스<br> 인증은 사용자가 부분적으로 직접 변경할 수 있지만 , 인가는 접근 완전 불가능</details>

#### 백엔드
##### <details markdown="1"><summary>세션 방식과 JWT 방식</summary>`세션 인증방식과 토큰 인증 방식의 차이점`<br>세션 : 인증 정보가 서버에 저장되어 있는 상태 , Client는 쿠키 헤더에 세션 ID 를 같이 보낸다. 서버에서는 세션 ID를 받아서 이걸 활용하여 인증을 확인한다.<br>JWT(JSON WEB TOKEN) : 인증 정보를 모두 Client가 들고 있다. 그래서 서버에서는 세션 방식과 같이 받아서 확인을 하는 절차를 밟지 않아도 되기 때문에 부담이 덜 간다.(사용자가 많은 경우에 부담이 덜감) , 그리고 쿠키에 모든 정보(?)를 담아서 보냄 , 서버에서는 만료 시각이 지나지 않았는지만 확인하고 통과 시킴<br> 이러한 방식으로 인해서 JWT 는 많은 보안 이슈를 불러 일으킬 수 있음 , 근데 잘 만 하면 괜찮음</details>
